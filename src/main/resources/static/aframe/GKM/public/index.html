<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Escape Room</title>

    <!-- A-Frame 및 컴포넌트 스크립트 -->
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.min.js"></script>
    <script src="https://unpkg.com/aframe-environment-component@1.3.2/dist/aframe-environment-component.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-physics-system@4.2.2/dist/aframe-physics-system.min.js"></script>
    
    <!-- 캐릭터 움직임 컨트롤 스크립트 수정 -->
    <script>
      AFRAME.registerComponent('character-movement', {
        init: function () {
          this.model = this.el;
          this.speed = 0.2;
          this.moveVector = new THREE.Vector3();
          
          // 마우스 이벤트를 위한 변수들
          this.isMouseDown = false;
          this.previousMouseX = 0;
          this.previousMouseY = 0;
          this.mouseSensitivity = 0.002;
          this.rotationX = 0; // 상하 회전을 위한 변수 추가
          
          // 점프 관련 변수 추가
          this.isJumping = false;
          this.jumpVelocity = 0;
          this.jumpSpeed = 0.2;
          this.gravity = 0.006;
          this.groundLevel = 0;
          
          // 키보드 상태 추적에 스페이스바 추가
          this.keys = {
            w: false,
            s: false,
            a: false,
            d: false,
            ' ': false  // 스페이스 바
          };
          
          // 키보드 이벤트
          document.addEventListener('keydown', (e) => {
            if (this.keys.hasOwnProperty(e.key.toLowerCase())) {
              this.keys[e.key.toLowerCase()] = true;
            }
          });
          
          document.addEventListener('keyup', (e) => {
            if (this.keys.hasOwnProperty(e.key.toLowerCase())) {
              this.keys[e.key.toLowerCase()] = false;
            }
          });
          
          // 마우스 이벤트
          document.addEventListener('mousedown', (e) => {
            this.isMouseDown = true;
            this.previousMouseX = e.clientX;
            this.previousMouseY = e.clientY;
          });
          
          document.addEventListener('mouseup', () => {
            this.isMouseDown = false;
          });
          
          document.addEventListener('mousemove', (e) => {
            if (this.isMouseDown) {
              const deltaX = e.clientX - this.previousMouseX;
              const deltaY = e.clientY - this.previousMouseY;
              
              // 좌우 회전은 캐릭터와 함께
              this.model.object3D.rotation.y -= deltaX * this.mouseSensitivity;
              
              // 상하 회전은 시점만
              this.rotationX -= deltaY * this.mouseSensitivity;
              this.rotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, this.rotationX));
              
              this.previousMouseX = e.clientX;
              this.previousMouseY = e.clientY;
            }
          });
          
          // 애니메이션 상태 추가
          this.currentAnimation = 'Idle0';
          this.model.addEventListener('model-loaded', () => {
            this.mixer = new THREE.AnimationMixer(this.model.object3D);
            this.animations = this.model.getObject3D('mesh').animations;
            this.actions = {};
            
            // 모든 애니메이션 액션 생성
            this.animations.forEach(animation => {
              this.actions[animation.name] = this.mixer.clipAction(animation);
            });
            
            // 초기 Idle 애니메이션 시작
            this.playAnimation('Idle0');
          });
        },
        
        playAnimation: function(newAnim) {
          if (this.currentAnimation === newAnim) return;
          
          // 이전 애니메이션 페이드아웃
          if (this.actions[this.currentAnimation]) {
            this.actions[this.currentAnimation].fadeOut(0.2);
          }
          
          // 새 애니메이션 페이드인
          if (this.actions[newAnim]) {
            this.actions[newAnim].reset().fadeIn(0.2).play();
            this.currentAnimation = newAnim;
          }
        },
        
        tick: function(time, deltaTime) {
          // 이동 방향 계산
          this.moveVector.set(0, 0, 0);
          
          // 전진/후진
          if (this.keys.w) this.moveVector.z = this.speed;
          if (this.keys.s) this.moveVector.z = -this.speed;
          
          // A/D 키로 회전
          if (this.keys.a) {
            this.model.object3D.rotation.y += 0.03;
          }
          if (this.keys.d) {
            this.model.object3D.rotation.y -= 0.03;
          }
          
          // 점프 처리
          if (this.keys[' '] && !this.isJumping) {
            this.isJumping = true;
            this.jumpVelocity = this.jumpSpeed;
          }
          
          // 점프 물리 계산
          if (this.isJumping) {
            this.model.object3D.position.y += this.jumpVelocity;
            this.jumpVelocity -= this.gravity;
            
            // 바닥에 닿았는지 확인
            if (this.model.object3D.position.y <= this.groundLevel) {
              this.model.object3D.position.y = this.groundLevel;
              this.isJumping = false;
              this.jumpVelocity = 0;
            }
          }
          
          // 캐릭터의 회현재 회전에 따라 이동 방향 조정
          this.moveVector.applyQuaternion(this.model.object3D.quaternion);
          
          // 수평 이동만 사용 (y값은 점프에서 처리)
          this.model.object3D.position.x += this.moveVector.x;
          this.model.object3D.position.z += this.moveVector.z;
          
          // 애니메이션 태 데이트
          if (this.mixer) {
            this.mixer.update(deltaTime / 1000);
            
            // 애니메이션 태 정
            if (this.isJumping) {
              this.playAnimation('Jumping0');
            } else if (this.keys.w || this.keys.s) {
              this.playAnimation('Walking0');
            } else {
              this.playAnimation('Idle0');
            }
          }
        }
      });
    </script>

    <!-- 카메라 팔로우 스크립트 수정 -->
    <script>
      AFRAME.registerComponent('camera-follow', {
        schema: {
          target: { type: 'selector' },
          distance: { type: 'number', default: 5 },
          height: { type: 'number', default: 2 }
        },
        
        init: function() {
          this.cameraRotation = new THREE.Euler();
        },
        
        tick: function() {
          if (!this.data.target) return;
          
          const targetPosition = this.data.target.object3D.position;
          const targetRotation = this.data.target.object3D.rotation;
          const characterMovement = this.data.target.components['character-movement'];
          
          // 카메라 위치 계산
          const offset = new THREE.Vector3(
            0,
            this.data.height,
            -this.data.distance
          );
          
          // 캐릭터의 좌우 회전만 따라가기
          offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), targetRotation.y);
          
          // 카메라 위치 업데이트
          this.el.object3D.position.x = targetPosition.x + offset.x;
          this.el.object3D.position.y = targetPosition.y + offset.y;
          this.el.object3D.position.z = targetPosition.z + offset.z;
          
          // 시점 회전 적용 (roll 회전 없이)
          if (characterMovement) {
            this.el.object3D.rotation.set(
              characterMovement.rotationX,
              targetRotation.y + Math.PI,
              0  // roll(z축 회전)을 0으로 고정
            );
          }
        }
      });
    </script>

    <!-- 게임 상태 관리 컴포넌트 -->
    <script>
      AFRAME.registerComponent('game-manager', {
        init: function() {
          this.gameTime = 100;
          this.isGameOver = false;
          this.timerEl = document.createElement('div');
          this.timerEl.style.position = 'fixed';
          this.timerEl.style.top = '20px';
          this.timerEl.style.left = '20px';
          this.timerEl.style.color = 'white';
          this.timerEl.style.fontSize = '24px';
          document.body.appendChild(this.timerEl);
          
          this.startGame();
        },

        startGame: function() {
          this.startTime = Date.now();
          this.updateTimer();
        },

        updateTimer: function() {
          if (this.isGameOver) return;
          
          const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
          const remaining = Math.max(0, this.gameTime - elapsed);
          this.timerEl.textContent = `남은 시간: ${remaining}초`;
          
          if (remaining <= 0) {
            this.gameWin();
          } else {
            requestAnimationFrame(this.updateTimer.bind(this));
          }
        },

        gameWin: function() {
          this.isGameOver = true;
          this.showMessage('탈출 성공!', '#4CAF50');
        },

        gameLose: function() {
          this.isGameOver = true;
          this.showMessage('게임 오버!', '#F44336');
        },

        showMessage: function(text, color) {
          const messageEl = document.createElement('div');
          messageEl.style.position = 'fixed';
          messageEl.style.top = '50%';
          messageEl.style.left = '50%';
          messageEl.style.transform = 'translate(-50%, -50%)';
          messageEl.style.color = color;
          messageEl.style.fontSize = '48px';
          messageEl.style.fontWeight = 'bold';
          messageEl.style.textShadow = '2px 2px 4px rgba(0,0,0,0.5)';
          messageEl.textContent = text;
          document.body.appendChild(messageEl);
        }
      });

      // 좀비 AI 컴포넌트
      AFRAME.registerComponent('zombie-ai', {
        schema: {
          target: {type: 'selector'},
          speed: {type: 'number', default: 0.1},
          detectionRange: {type: 'number', default: 99999},
          attackRange: {type: 'number', default: 1}
        },

        init: function() {
          this.zombie = this.el;
          this.moveVector = new THREE.Vector3();
          this.currentAnimation = '';
          this.isGameOver = false;
          this.targetPosition = new THREE.Vector3();
          this.zombiePosition = new THREE.Vector3();

          this.zombie.addEventListener('model-loaded', () => {
            console.log('Model loaded for zombie:', this.el.id);
            const model = this.zombie.getObject3D('mesh');
            this.mixer = new THREE.AnimationMixer(model);
            this.animations = model.animations;
            this.actions = {};
            
            this.animations.forEach(animation => {
              const action = this.mixer.clipAction(animation);
              action.setLoop(THREE.LoopRepeat);
              action.clampWhenFinished = true;
              action.timeScale = 1.0;
              this.actions[animation.name] = action;
            });
            
            this.playAnimation('ZombieRunning');
          });
        },

        tick: function(time, deltaTime) {
          if (!this.mixer || !this.data.target) return;
          
          const delta = Math.min(deltaTime / 1000, 0.1);
          this.mixer.update(delta);
          
          if (this.el.sceneEl.components['game-manager'].isGameOver) {
            if (!this.isGameOver) {
              this.isGameOver = true;
              this.playAnimation('ZombieIdle');
            }
            return;
          }

          // 위치 업데이트
          this.data.target.object3D.getWorldPosition(this.targetPosition);
          this.zombie.object3D.getWorldPosition(this.zombiePosition);
          
          // 이동 방향 계산
          this.moveVector.subVectors(this.targetPosition, this.zombiePosition).normalize();
          
          // 이동 적용
          const moveAmount = this.data.speed * (deltaTime / 16.67);
          this.zombie.object3D.position.x += this.moveVector.x * moveAmount;
          this.zombie.object3D.position.z += this.moveVector.z * moveAmount;
          
          // 향상된 회전 로직
          const dx = this.targetPosition.x - this.zombiePosition.x;
          const dz = this.targetPosition.z - this.zombiePosition.z;
          const targetAngle = Math.atan2(dx, dz);
          
          // 부드러운 회전을 위한 보간
          const currentRotation = this.zombie.object3D.rotation.y;
          const rotationDiff = targetAngle - currentRotation;
          
          // 회전각 정규화 (-PI to PI)
          let normalizedDiff = rotationDiff;
          while (normalizedDiff > Math.PI) normalizedDiff -= Math.PI * 2;
          while (normalizedDiff < -Math.PI) normalizedDiff += Math.PI * 2;
          
          // 부드러운 회전 적용
          const rotationSpeed = 0.1;
          this.zombie.object3D.rotation.y += normalizedDiff * rotationSpeed;
          
          // 거리 체크
          const distance = this.zombiePosition.distanceTo(this.targetPosition);
          
          if (distance <= this.data.attackRange) {
            this.el.sceneEl.components['game-manager'].gameLose();
            return;
          }
          
          // 애니메이션
          if (this.currentAnimation !== 'ZombieRunning') {
            this.playAnimation('ZombieRunning');
          }
        },

        playAnimation: function(newAnim) {
          if (this.currentAnimation === newAnim || !this.actions) return;
          
          if (this.actions[this.currentAnimation]) {
            this.actions[this.currentAnimation].fadeOut(0.5);
          }
          
          if (this.actions[newAnim]) {
            this.actions[newAnim]
              .reset()
              .fadeIn(0.5)
              .play();
            
            this.currentAnimation = newAnim;
          }
        }
      });

      AFRAME.registerComponent('zombie-spawner', {
        init: function() {
          console.log('Zombie spawner initialized');
          this.spawnTimer = 0;
          this.spawnInterval = 10000;
          this.zombieCount = 1;
          
          setTimeout(() => this.spawnZombie(), 1000);
        },

        spawnZombie: function() {
          const minX = -8;
          const maxX = 40;
          const minZ = -140;
          const maxZ = 35;

          const randomX = minX + Math.random() * (maxX - minX);
          const randomZ = minZ + Math.random() * (maxZ - minZ);

          const newZombie = document.createElement('a-entity');
          newZombie.setAttribute('id', 'zombie-' + Date.now());
          newZombie.setAttribute('gltf-model', './models/zombie/scene.gltf');
          newZombie.setAttribute('scale', '0.02 0.02 0.02');
          newZombie.setAttribute('animation-mixer', '');
          newZombie.setAttribute('position', `${randomX} 0 ${randomZ}`);
          
          // 속도를 0.1로 설정
          newZombie.setAttribute('zombie-ai', {
            target: '#character',
            speed: 0.1,
            detectionRange: 99999,
            attackRange: 1
          });

          this.el.sceneEl.appendChild(newZombie);
          console.log('New zombie spawned at:', randomX, 0, randomZ);
        },

        tick: function(time, deltaTime) {
          if (this.el.sceneEl.components['game-manager'].isGameOver) {
            return;
          }

          this.spawnTimer += deltaTime;
          
          if (this.spawnTimer >= this.spawnInterval) {
            this.spawnTimer = 0;
            this.spawnZombie();
          }
        }
      });
    </script>
</head>
<body>
    <a-scene loading-screen="dotsColor: white; backgroundColor: #000000" game-manager>
        <!-- 창고 모델 추가 -->
        <a-entity
            id="warehouse"
            gltf-model="./models/warehouse/scene.gltf"
            position="-15 -2 40"
            scale="4 4 4"
            rotation="0 0 0">
        </a-entity>

        <!-- 조명 -->
        <a-light type="ambient" color="#ffffff" intensity="0.5"></a-light>
        <a-light type="directional" color="#ffffff" intensity="1" position="-1 2 1"></a-light>

        <!-- 바닥 추가 -->
        <a-plane 
            position="15 -2 -80" 
            rotation="-90 0 0" 
            scale="1 3 1"
            width="100" 
            height="100" 
            material="
                color: #7BC8A4;
                wireframe: true;
                wireframeLinewidth: 2;
                src: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOxAAADsQBlSsOGwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAEQSURBVHic7ZjBDYQwDARPKYSH9N9NekgJz4MQsuPY3mSllXYeYGac9badX+f9+Nw93+f9+AIwxoAxBowxYIwBYwwYY8AYA8YYMMaAMQaMMWCMAWMMGGPAGAPGGDDGgDEGjDFgzO0Abre0Y8f+HTk/eu2j86s4/n0PYAVgjAFjDBhjwBgDxhgwxoAxBowxYIwBYwwYY8AYA8YYMMaAMQaMMWCMAWMMGGPAmNsBsP8JzHZ+FQaMMWCMAWMMGGPAGAPGGDDGgDEGjDFgjAFjDBhjwBgDxhgw5guNjCTwPZGG1gAAAABJRU5ErkJggg==);
                repeat: 100 100"
            shadow>
        </a-plane>

        <!-- 3D 모델 -->
        <a-entity
            id="character"
            gltf-model="./models/player/player.gltf"
            position="0 0 0"
            scale="0.01 0.01 0.01"
            rotation="0 0 0"
            character-movement>
        </a-entity>

        <!-- 3인칭 카메라 업데이트 -->
        <a-entity 
            id="camera" 
            camera 
            position="0 2 3"
            camera-follow="target: #character; distance: 3; height: 1.5">
            <a-cursor color="#FAFAFA"></a-cursor>
        </a-entity>

        <!-- 좀비 스포너 -->
        <a-entity id="zombie-spawner" zombie-spawner="enabled: true"></a-entity>
        
        <!-- 초기 좀비는 제거 (스포너가 생성할 것이므로) -->
    </a-scene>
</body>
</html>
