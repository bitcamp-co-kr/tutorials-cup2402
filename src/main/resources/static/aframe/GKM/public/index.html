<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Escape Room</title>

    <!-- A-Frame 및 컴포넌트 스크립트 -->
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.min.js"></script>
    <script src="https://unpkg.com/aframe-environment-component@1.3.2/dist/aframe-environment-component.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-physics-system@4.2.2/dist/aframe-physics-system.min.js"></script>
    
    <!-- 캐릭터 움직임 컨트롤 스크립트 수정 -->
    <script>
      AFRAME.registerComponent('character-movement', {
        init: function () {
          this.model = this.el;
          this.speed = 0.2;
          this.moveVector = new THREE.Vector3();
          
          // 마우스 이벤트를 위한 변수들
          this.isMouseDown = false;
          this.previousMouseX = 0;
          this.previousMouseY = 0;
          this.mouseSensitivity = 0.002;
          this.rotationX = 0; // 상하 회전을 위한 변수 추가
          
          // 점프 관련 변수 추가
          this.isJumping = false;
          this.jumpVelocity = 0;
          this.jumpSpeed = 0.2;
          this.gravity = 0.006;
          this.groundLevel = 0;
          
          // 키보드 상태 추적에 스페이스바 추가
          this.keys = {
            w: false,
            s: false,
            a: false,
            d: false,
            ' ': false  // 스페이스 바
          };
          
          // 키보드 이벤트
          document.addEventListener('keydown', (e) => {
            if (this.keys.hasOwnProperty(e.key.toLowerCase())) {
              this.keys[e.key.toLowerCase()] = true;
            }
          });
          
          document.addEventListener('keyup', (e) => {
            if (this.keys.hasOwnProperty(e.key.toLowerCase())) {
              this.keys[e.key.toLowerCase()] = false;
            }
          });
          
          // 마우스 이벤트
          document.addEventListener('mousedown', (e) => {
            this.isMouseDown = true;
            this.previousMouseX = e.clientX;
            this.previousMouseY = e.clientY;
          });
          
          document.addEventListener('mouseup', () => {
            this.isMouseDown = false;
          });
          
          document.addEventListener('mousemove', (e) => {
            if (this.isMouseDown) {
              const deltaX = e.clientX - this.previousMouseX;
              const deltaY = e.clientY - this.previousMouseY;
              
              // 좌우 회전은 캐릭터와 함께
              this.model.object3D.rotation.y -= deltaX * this.mouseSensitivity;
              
              // 상하 회전은 시점만
              this.rotationX -= deltaY * this.mouseSensitivity;
              this.rotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, this.rotationX));
              
              this.previousMouseX = e.clientX;
              this.previousMouseY = e.clientY;
            }
          });
          
          // 애니메이션 상태 추가
          this.currentAnimation = 'Idle0';
          this.model.addEventListener('model-loaded', () => {
            this.mixer = new THREE.AnimationMixer(this.model.object3D);
            this.animations = this.model.getObject3D('mesh').animations;
            this.actions = {};
            
            // 모든 애니메이션 액션 생성
            this.animations.forEach(animation => {
              this.actions[animation.name] = this.mixer.clipAction(animation);
            });
            
            // 초기 Idle 애니메이션 시작
            this.playAnimation('Idle0');
          });
        },
        
        playAnimation: function(newAnim) {
          if (this.currentAnimation === newAnim) return;
          
          // 이전 애니메이션 페이드아웃
          if (this.actions[this.currentAnimation]) {
            this.actions[this.currentAnimation].fadeOut(0.2);
          }
          
          // 새 애니메이션 페이드인
          if (this.actions[newAnim]) {
            this.actions[newAnim].reset().fadeIn(0.2).play();
            this.currentAnimation = newAnim;
          }
        },
        
        tick: function(time, deltaTime) {
          // 이동 방향 계산
          this.moveVector.set(0, 0, 0);
          
          // 전진/후진
          if (this.keys.w) this.moveVector.z = this.speed;
          if (this.keys.s) this.moveVector.z = -this.speed;
          
          // A/D 키로 회전
          if (this.keys.a) {
            this.model.object3D.rotation.y += 0.03;
          }
          if (this.keys.d) {
            this.model.object3D.rotation.y -= 0.03;
          }
          
          // 점프 처리
          if (this.keys[' '] && !this.isJumping) {
            this.isJumping = true;
            this.jumpVelocity = this.jumpSpeed;
          }
          
          // 점프 물리 계산
          if (this.isJumping) {
            this.model.object3D.position.y += this.jumpVelocity;
            this.jumpVelocity -= this.gravity;
            
            // 바닥에 닿았는지 확인
            if (this.model.object3D.position.y <= this.groundLevel) {
              this.model.object3D.position.y = this.groundLevel;
              this.isJumping = false;
              this.jumpVelocity = 0;
            }
          }
          
          // 캐릭터의 회현재 회전에 따라 이동 방향 조정
          this.moveVector.applyQuaternion(this.model.object3D.quaternion);
          
          // 수평 이동만 사용 (y값은 점프에서 처리)
          this.model.object3D.position.x += this.moveVector.x;
          this.model.object3D.position.z += this.moveVector.z;
          
          // 애니메이션 태 데이트
          if (this.mixer) {
            this.mixer.update(deltaTime / 1000);
            
            // 애니메이션 태 정
            if (this.isJumping) {
              this.playAnimation('Jumping0');
            } else if (this.keys.w || this.keys.s) {
              this.playAnimation('Walking0');
            } else {
              this.playAnimation('Idle0');
            }
          }
        }
      });
    </script>

    <!-- 카메라 팔로우 스크립트 수정 -->
    <script>
      AFRAME.registerComponent('camera-follow', {
        schema: {
          target: { type: 'selector' },
          distance: { type: 'number', default: 5 },
          height: { type: 'number', default: 2 }
        },
        
        init: function() {
          this.cameraRotation = new THREE.Euler();
        },
        
        tick: function() {
          if (!this.data.target) return;
          
          const targetPosition = this.data.target.object3D.position;
          const targetRotation = this.data.target.object3D.rotation;
          const characterMovement = this.data.target.components['character-movement'];
          
          // 카메라 위치 계산
          const offset = new THREE.Vector3(
            0,
            this.data.height,
            -this.data.distance
          );
          
          // 캐릭터의 좌우 회전만 따라가기
          offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), targetRotation.y);
          
          // 카메라 위치 업데이트
          this.el.object3D.position.x = targetPosition.x + offset.x;
          this.el.object3D.position.y = targetPosition.y + offset.y;
          this.el.object3D.position.z = targetPosition.z + offset.z;
          
          // 시점 회전 적용 (roll 회전 없이)
          if (characterMovement) {
            this.el.object3D.rotation.set(
              characterMovement.rotationX,
              targetRotation.y + Math.PI,
              0  // roll(z축 회전)을 0으로 고정
            );
          }
        }
      });
    </script>

    <!-- 게임 상태 관리 컴포넌트 -->
    <script>
      AFRAME.registerComponent('game-manager', {
        init: function() {
          this.gameTime = 100;
          this.isGameOver = false;
          this.isGameStarted = false;
          this.playerName = '';
          
          // 시작 화면 생성
          this.createStartScreen();
          
          // 타이머 엘리먼트 생성
          this.timerEl = document.createElement('div');
          this.timerEl.style.position = 'fixed';
          this.timerEl.style.top = '20px';
          this.timerEl.style.left = '20px';
          this.timerEl.style.color = 'white';
          this.timerEl.style.fontSize = '24px';
          this.timerEl.style.display = 'none';
          document.body.appendChild(this.timerEl);
        },

        createStartScreen: function() {
          const startScreen = document.createElement('div');
          startScreen.id = 'startScreen';
          startScreen.style.position = 'fixed';
          startScreen.style.top = '0';
          startScreen.style.left = '0';
          startScreen.style.width = '100%';
          startScreen.style.height = '100%';
          startScreen.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
          startScreen.style.display = 'flex';
          startScreen.style.flexDirection = 'column';
          startScreen.style.justifyContent = 'center';
          startScreen.style.alignItems = 'center';
          startScreen.style.zIndex = '1000';

          startScreen.innerHTML = `
            <h1 style="color: white; font-size: 3em; margin-bottom: 1em;">좀비 탈출 게임</h1>
            <div style="margin: 2em 0;">
              <input type="text" id="playerName" placeholder="플레이어 이름을 입력하세요" 
                     style="padding: 0.5em; font-size: 1.2em; margin-right: 1em;">
              <button id="startButton" 
                      style="padding: 0.5em 1em; font-size: 1.2em; background: #4CAF50; color: white; border: none; cursor: pointer;">
                게임 시작
              </button>
            </div>
            <div style="color: white; text-align: center;">
              <h2>클리어 목록</h2>
              <ul id="leaderboardList" style="list-style: none; padding: 0;"></ul>
            </div>
          `;

          document.body.appendChild(startScreen);

          // 이벤트 리스너 추가
          document.getElementById('startButton').addEventListener('click', () => {
            const name = document.getElementById('playerName').value.trim();
            if (name) {
              this.playerName = name;
              this.startGame();
            } else {
              alert('플레이어 이름을 입력해주세요!');
            }
          });

          // 초기 리더보드 로드
          this.loadLeaderboard();
        },

        startGame: function() {
          this.isGameStarted = true;
          this.startTime = Date.now();
          document.getElementById('startScreen').style.display = 'none';
          this.timerEl.style.display = 'block';
          this.updateTimer();
        },

        updateTimer: function() {
          if (!this.isGameStarted || this.isGameOver) return;
          
          const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
          const remaining = Math.max(0, this.gameTime - elapsed);
          this.timerEl.textContent = `남은 시간: ${remaining}초`;
          
          if (remaining <= 0) {
            this.gameWin();
          } else {
            requestAnimationFrame(this.updateTimer.bind(this));
          }
        },

        async loadLeaderboard() {
          try {
            const response = await fetch('/api/records');
            const records = await response.json();
            
            const leaderboardList = document.getElementById('leaderboardList');
            leaderboardList.innerHTML = records
              .map((record, index) => `
                <li style="margin: 0.5em 0;">
                  ${index + 1}. ${record.player_name} - ${record.clear_time}초
                </li>
              `)
              .join('');
          } catch (error) {
            console.error('리더보드 로드 실패:', error);
          }
        },

        gameWin: function() {
          this.isGameOver = true;
          const clearTime = Math.floor((Date.now() - this.startTime) / 1000);
          
          // 기록 저장 먼저 실행
          fetch('/api/records', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              playerName: this.playerName,
              clearTime: clearTime
            })
          })
          .then(response => {
            if (!response.ok) {
              throw new Error('기록 저장 실패');
            }
            return response.json();
          })
          .then(() => {
            // 승리 화면 표시
            const winScreen = document.createElement('div');
            winScreen.style.position = 'fixed';
            winScreen.style.top = '0';
            winScreen.style.left = '0';
            winScreen.style.width = '100%';
            winScreen.style.height = '100%';
            winScreen.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            winScreen.style.display = 'flex';
            winScreen.style.flexDirection = 'column';
            winScreen.style.justifyContent = 'center';
            winScreen.style.alignItems = 'center';
            winScreen.style.zIndex = '1000';

            winScreen.innerHTML = `
              <h1 style="color: #4CAF50; font-size: 3em; margin-bottom: 0.5em;">탈출 성공!</h1>
              <p style="color: white; font-size: 1.5em; margin-bottom: 1em;">
                플레이어: ${this.playerName}<br>
                클리어 시간: ${clearTime}초
              </p>
              <button id="restartButton" 
                      style="padding: 0.5em 1em; font-size: 1.2em; background: #4CAF50; 
                             color: white; border: none; cursor: pointer; margin-bottom: 2em;">
                다시하기
              </button>
              <div style="color: white; text-align: center;">
                <h2>클리어 목록</h2>
                <ul id="winLeaderboardList" style="list-style: none; padding: 0; max-height: 300px; overflow-y: auto;"></ul>
              </div>
            `;

            document.body.appendChild(winScreen);

            // 다시하기 버튼 이벤트 리스너
            document.getElementById('restartButton').addEventListener('click', () => {
              window.location.reload();
            });

            // 리더보드 업데이트
            this.loadWinLeaderboard();
          })
          .catch(error => {
            console.error('기록 저장 실패:', error);
            // 에러가 발생해도 승리 화면은 표시
            this.showWinScreen(clearTime);
          });
        },

        // 승리 화면용 리더보드 로드 함수
        async loadWinLeaderboard() {
          try {
            const response = await fetch('/api/records');
            const records = await response.json();
            
            const leaderboardList = document.getElementById('winLeaderboardList');
            leaderboardList.innerHTML = records
              .map((record, index) => `
                <li style="margin: 0.5em 0; font-size: 1.2em;">
                  ${index + 1}. ${record.player_name} - ${record.clear_time}초
                </li>
              `)
              .join('');
          } catch (error) {
            console.error('리더보드 로드 실패:', error);
          }
        },

        gameLose: function() {
          this.isGameOver = true;
          
          const loseScreen = document.createElement('div');
          loseScreen.style.position = 'fixed';
          loseScreen.style.top = '0';
          loseScreen.style.left = '0';
          loseScreen.style.width = '100%';
          loseScreen.style.height = '100%';
          loseScreen.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
          loseScreen.style.display = 'flex';
          loseScreen.style.flexDirection = 'column';
          loseScreen.style.justifyContent = 'center';
          loseScreen.style.alignItems = 'center';
          loseScreen.style.zIndex = '1000';

          loseScreen.innerHTML = `
            <h1 style="color: #F44336; font-size: 3em; margin-bottom: 1em;">게임 오버!</h1>
            <button id="restartButton" 
                    style="padding: 0.5em 1em; font-size: 1.2em; background: #F44336; 
                           color: white; border: none; cursor: pointer;">
              다시하기
            </button>
          `;

          document.body.appendChild(loseScreen);

          document.getElementById('restartButton').addEventListener('click', () => {
            window.location.reload();
          });
        },

        showMessage: function(text, color) {
          const messageEl = document.createElement('div');
          messageEl.style.position = 'fixed';
          messageEl.style.top = '50%';
          messageEl.style.left = '50%';
          messageEl.style.transform = 'translate(-50%, -50%)';
          messageEl.style.color = color;
          messageEl.style.fontSize = '48px';
          messageEl.style.fontWeight = 'bold';
          messageEl.style.textShadow = '2px 2px 4px rgba(0,0,0,0.5)';
          messageEl.textContent = text;
          document.body.appendChild(messageEl);
        }
      });

      // 좀비 AI 컴포넌트
      AFRAME.registerComponent('zombie-ai', {
        schema: {
          target: {type: 'selector'},
          speed: {type: 'number', default: 0.1},
          detectionRange: {type: 'number', default: 99999},
          attackRange: {type: 'number', default: 1}
        },

        init: function() {
          this.zombie = this.el;
          this.moveVector = new THREE.Vector3();
          this.currentAnimation = '';
          this.isGameOver = false;
          this.targetPosition = new THREE.Vector3();
          this.zombiePosition = new THREE.Vector3();

          this.zombie.addEventListener('model-loaded', () => {
            console.log('Model loaded for zombie:', this.el.id);
            const model = this.zombie.getObject3D('mesh');
            this.mixer = new THREE.AnimationMixer(model);
            this.animations = model.animations;
            this.actions = {};
            
            this.animations.forEach(animation => {
              const action = this.mixer.clipAction(animation);
              action.setLoop(THREE.LoopRepeat);
              action.clampWhenFinished = true;
              action.timeScale = 1.0;
              this.actions[animation.name] = action;
            });
            
            this.playAnimation('ZombieRunning');
          });
        },

        tick: function(time, deltaTime) {
          if (!this.mixer || !this.data.target) return;
          
          const delta = Math.min(deltaTime / 1000, 0.1);
          this.mixer.update(delta);
          
          if (this.el.sceneEl.components['game-manager'].isGameOver) {
            if (!this.isGameOver) {
              this.isGameOver = true;
              this.playAnimation('ZombieIdle');
            }
            return;
          }

          // 위치 업데이트
          this.data.target.object3D.getWorldPosition(this.targetPosition);
          this.zombie.object3D.getWorldPosition(this.zombiePosition);
          
          // 이동 방향 계산
          this.moveVector.subVectors(this.targetPosition, this.zombiePosition).normalize();
          
          // 이동 적용
          const moveAmount = this.data.speed * (deltaTime / 16.67);
          this.zombie.object3D.position.x += this.moveVector.x * moveAmount;
          this.zombie.object3D.position.z += this.moveVector.z * moveAmount;
          
          // 향상된 회전 로직
          const dx = this.targetPosition.x - this.zombiePosition.x;
          const dz = this.targetPosition.z - this.zombiePosition.z;
          const targetAngle = Math.atan2(dx, dz);
          
          // 부드러운 회전을 위한 보간
          const currentRotation = this.zombie.object3D.rotation.y;
          const rotationDiff = targetAngle - currentRotation;
          
          // 회전각 정규화 (-PI to PI)
          let normalizedDiff = rotationDiff;
          while (normalizedDiff > Math.PI) normalizedDiff -= Math.PI * 2;
          while (normalizedDiff < -Math.PI) normalizedDiff += Math.PI * 2;
          
          // 부드러운 회전 적용
          const rotationSpeed = 0.1;
          this.zombie.object3D.rotation.y += normalizedDiff * rotationSpeed;
          
          // 거리 체크
          const distance = this.zombiePosition.distanceTo(this.targetPosition);
          
          if (distance <= this.data.attackRange) {
            this.el.sceneEl.components['game-manager'].gameLose();
            return;
          }
          
          // 애니메이션
          if (this.currentAnimation !== 'ZombieRunning') {
            this.playAnimation('ZombieRunning');
          }
        },

        playAnimation: function(newAnim) {
          if (this.currentAnimation === newAnim || !this.actions) return;
          
          if (this.actions[this.currentAnimation]) {
            this.actions[this.currentAnimation].fadeOut(0.5);
          }
          
          if (this.actions[newAnim]) {
            this.actions[newAnim]
              .reset()
              .fadeIn(0.5)
              .play();
            
            this.currentAnimation = newAnim;
          }
        }
      });

      AFRAME.registerComponent('zombie-spawner', {
        init: function() {
          console.log('Zombie spawner initialized');
          this.spawnTimer = 0;
          this.spawnInterval = 10000;
          this.zombieCount = 1;
          
          setTimeout(() => this.spawnZombie(), 1000);
        },

        spawnZombie: function() {
          const minX = -8;
          const maxX = 40;
          const minZ = -140;
          const maxZ = 35;

          const randomX = minX + Math.random() * (maxX - minX);
          const randomZ = minZ + Math.random() * (maxZ - minZ);

          const newZombie = document.createElement('a-entity');
          newZombie.setAttribute('id', 'zombie-' + Date.now());
          newZombie.setAttribute('gltf-model', './models/zombie/scene.gltf');
          newZombie.setAttribute('scale', '0.02 0.02 0.02');
          newZombie.setAttribute('animation-mixer', '');
          newZombie.setAttribute('position', `${randomX} 0 ${randomZ}`);
          
          // 속도를 0.1로 설정
          newZombie.setAttribute('zombie-ai', {
            target: '#character',
            speed: 0.1,
            detectionRange: 99999,
            attackRange: 1
          });

          this.el.sceneEl.appendChild(newZombie);
          console.log('New zombie spawned at:', randomX, 0, randomZ);
        },

        tick: function(time, deltaTime) {
          if (this.el.sceneEl.components['game-manager'].isGameOver) {
            return;
          }

          this.spawnTimer += deltaTime;
          
          if (this.spawnTimer >= this.spawnInterval) {
            this.spawnTimer = 0;
            this.spawnZombie();
          }
        }
      });
    </script>
</head>
<body>
    <a-scene loading-screen="dotsColor: white; backgroundColor: #000000" game-manager>
        <!-- 창고 모델 추가 -->
        <a-entity
            id="warehouse"
            gltf-model="./models/warehouse/scene.gltf"
            position="-15 -2 40"
            scale="4 4 4"
            rotation="0 0 0">
        </a-entity>

        <!-- 조명 -->
        <a-light type="ambient" color="#ffffff" intensity="0.5"></a-light>
        <a-light type="directional" color="#ffffff" intensity="1" position="-1 2 1"></a-light>

        <!-- 바닥 추가 -->
        <a-plane 
            position="15 -2 -80" 
            rotation="-90 0 0" 
            scale="1 3 1"
            width="100" 
            height="100" 
            material="
                color: #7BC8A4;
                wireframe: true;
                wireframeLinewidth: 2;
                src: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOxAAADsQBlSsOGwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAEQSURBVHic7ZjBDYQwDARPKYSH9N9NekgJz4MQsuPY3mSllXYeYGac9badX+f9+Nw93+f9+AIwxoAxBowxYIwBYwwYY8AYA8YYMMaAMQaMMWCMAWMMGGPAGAPGGDDGgDEGjDFgzO0Abre0Y8f+HTk/eu2j86s4/n0PYAVgjAFjDBhjwBgDxhgwxoAxBowxYIwBYwwYY8AYA8YYMMaAMQaMMWCMAWMMGGPAmNsBsP8JzHZ+FQaMMWCMAWMMGGPAGAPGGDDGgDEGjDFgjAFjDBhjwBgDxhgw5guNjCTwPZGG1gAAAABJRU5ErkJggg==);
                repeat: 100 100"
            shadow>
        </a-plane>

        <!-- 3D 모델 -->
        <a-entity
            id="character"
            gltf-model="./models/player/player.gltf"
            position="0 0 0"
            scale="0.01 0.01 0.01"
            rotation="0 0 0"
            character-movement>
        </a-entity>

        <!-- 3인칭 카메라 업데이트 -->
        <a-entity 
            id="camera" 
            camera 
            position="0 2 3"
            camera-follow="target: #character; distance: 3; height: 1.5">
            <a-cursor color="#FAFAFA"></a-cursor>
        </a-entity>

        <!-- 좀비 스포너 -->
        <a-entity id="zombie-spawner" zombie-spawner="enabled: true"></a-entity>
        
        <!-- 초기 좀비는 제거 (스포너가 생성할 것이므로) -->
    </a-scene>
</body>
</html>
